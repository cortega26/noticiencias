---
import type { HTMLAttributes } from 'astro/types';
import { findImage } from '~/utils/images';
import { getAsset } from '~/utils/permalinks';
import { normalizeImage } from '~/utils/normalizeImage';
import {
  getImagesOptimized,
  astroAssetsOptimizer,
  unpicOptimizer,
  isUnpicCompatible,
  type ImageProps,
} from '~/utils/images-optimization';


type ImageType = {
  src: string;
  attributes: HTMLAttributes<'img'>;
};

interface Props extends ImageProps {
  fetchpriority?: 'high' | 'low' | 'auto';
}

const props = Astro.props;

// Normalization Limit
const normalized = normalizeImage(props.src);
if (!normalized) {
    // If src is missing, we can't render an image.
    // Astro might handle this via slot or just return null.
}
// Use Normalized Input as Source of Truth
const finalSrc = normalized ? normalized.src : (typeof props.src === 'string' ? props.src : '');
// If props.alt is missing, try normalized alt
if (props.alt === undefined || props.alt === null) {
    if (normalized && normalized.alt) {
        props.alt = normalized.alt;
    } else {
        // Fallback to empty string if missing? 
        // I-03 says explicit empty is better than undefined.
        // But throwing might be safer for strictness.
        // Let's keep existing strict check for now.
        // throw new Error();
    }
}

if (props.alt === undefined || props.alt === null) {
  throw new Error();
}

if (typeof props.width === 'string') {
  props.width = parseInt(props.width);
}

if (typeof props.height === 'string') {
  props.height = parseInt(props.height);
}

if (!props.loading) {
  props.loading = 'lazy';
}

if (!props.decoding) {
  props.decoding = 'async';
}

// Map Normalized Attributes to Props if missing
if (normalized) {
    if (!props.width && normalized.width) props.width = normalized.width;
    if (!props.height && normalized.height) props.height = normalized.height;
}

const _image = await findImage(finalSrc);

let image: ImageType | undefined = undefined;

if (
  typeof _image === 'string' &&
  (_image.startsWith('http://') || _image.startsWith('https://')) &&
  isUnpicCompatible(_image)
) {
  image = await getImagesOptimized(_image, props, unpicOptimizer);
} else if (_image) {
    // START PATCH: Handle public/ assets without dimensions
    if (typeof _image === 'string' && _image.startsWith('/')) {
        const attributes = { ...props };
        delete attributes.src;
        image = {
            src: getAsset(_image),
            attributes: {
                ...attributes,
                width: props.width,
                height: props.height,
            } as HTMLAttributes<'img'> // Explicit cast to satisfy TS
        };
    } else {
        image = await getImagesOptimized(_image, props, astroAssetsOptimizer);
    }
    // END PATCH
}
---

{
  !image ? (
    <Fragment />
  ) : (
    <img src={image.src} crossorigin="anonymous" referrerpolicy="no-referrer" {...image.attributes} />
  )
}
